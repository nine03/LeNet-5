# LeNet-5


### 开发环境(Development Environment 개발환경)
- PyCharm
- Python
- Torch

### 发展背景和基本概念

卷积神经网络（Convolutional Neural Network，CNN）是一种前馈型的神经网络，其在大型图像处理方面有出色的表现，目前已经被大范围使用到图像分类、定位等领域中。相比于其他神经网络结构，卷积神经网络需要的参数相对较少，使的其能够广泛应用。

 卷积神经网络是目前深度学习技术领域中非常具有代表性的神经网络之一，在图像分析和处理领域取得了众多突破性的进展，在学术界常用的标准图像标注集ImageNet上，基于卷积神经网络取得了很多成就，包括图像特征提取分类、场景识别等。卷积神经网络相较于传统的图像处理算法的优点之一在于避免了对图像复杂的前期预处理过程，尤其是人工参与图像预处理过程，卷积神经网络可以直接输入原始图像进行一系列工作，至今己经广泛应用于各类图像相关的应用中。
       从卷积神经网络的提出到目前的广泛应用，大致经历了理论萌芽阶段、实验发展阶段以及大规模应用和深入研究阶段。
（1）理论萌芽阶段。1962年Hubel以及Wiesel通过生物学研究表明，从视网膜传递脑中的视觉信息是通过多层次的感受野（Receptive Field）激发完成的，并首先提出了感受野的概念。1980年日本学者Fukushima在基于感受野的概念基础之上，提出了神经认知机(Neocognitron)。神经认知机是一个自组织的多层神经网络模型，每一层的响应都由上一层的局部感受野激发得到，对于模式的识别不受位置、较小形状变化以及尺度大小的影响。神经认知机可以理解为卷积神经网络的第一版，核心点在于将视觉系统模型化，并且不受视觉中的位置和大小等影响。 

（2）实验发展阶段。1998年计算机科学家Yann LeCun等提出的LeNet-5采用了基于梯度的反向传播算法对网络进行有监督的训练，Yann LeCun在机器学习、计算机视觉等都有杰出贡献，被誉为卷积神经网络之父。LeNet-5网络通过交替连接的卷积层和下采样层，将原始图像逐渐转换为一系列的特征图，并且将这些特征传递给全连接的神经网络，以根据图像的特征对图像进行分类。感受野是卷积神经网络的核心，卷积神经网络的卷积核则是感受野概念的结构表现。学术界对于卷积神经网络的关注，也正是开始于LeNet-5网络的提出，并成功应用于手写体识别。同时，卷积神经网络在语音识别、物体检测、人脸识别等应用领域的研究也逐渐开展起来。
（3）大规模应用和深入研究阶段。在LeNet-5网络之后，卷积神经网络一直处于实验发展阶段。直到2012年AlexNet网络的提出才奠定了卷积神经网络在深度学习应用中的地位，Krizhevsky（他是hintion的学生对应的论文就是刚开始提到的深度卷积神经网络）等提出的卷积神经网络AlexNet在ImageNet的训练集上取得了图像分类的冠军，使得卷积神经网络成为计算机视觉中的重点研究对象，并且不断深入。在AlexNet之后，不断有新的卷积神经网络提出，包括牛津大学的VGG网络、微软的ResNet网络、谷歌的GoogLeNet网络等，这些网络的提出使得卷积神经网络逐步开始走向商业化应用，几乎只要是存在图像的地方，就会有卷积神经网络的身影。
       从目前的发展趋势而言，卷积神经网络将依然会持续发展，并且会产生适合各类应用场景的卷积神经网络，例如，面向视频理解的3D卷积神经网络等。值得说明的是，卷积神经网络不仅仅应用于图像相关的网络，还包括与图像相似的网络，例如，在围棋中分析棋盘等。

基本概念

 卷积神经网络中有三个基本的概念：局部感受野（Local Receptive Fields）、共享权值(Shared Weights）、池化（Pooling)。
（1）局部感受野。对于一般的深度神经网络，往往会把图像的每一个像素点连接到全连接的每一个神经元中，而卷积神经网络则是把每一个隐藏节点只连接到图像的某个局部区域，从而减少参数训练的数量。例如，一张1024×720的图像，使用9×9的感受野，则只需要81个权值参数。对于一般的视觉也是如此，当观看一张图像时，更多的时候关注的是局部。
（2）共享权值。在卷积神经网络的卷积层中，神经元对应的权值是相同的，由于权值相同，因此可以减少训练的参数量。共享的权值和偏置也被称作卷积核或滤汲器。
（3）池化。由于待处理的图像往往都比较大，而在实际过程中，没有必要对原图进行分析，能够有效获得图像的特征才是最主要的，因此可以采用类似于图像压缩的思想，对图像进行卷积之后，通过一个下采样过程，来调整图像的大小。

### 主要原理(주요원리)

1. 数据集

Mnist 数据集是一个手写数字图片数据集，数据集的下载和解读详见Mnist数据集解读。这里为了对接pythorch的神经网络，需要将数据集制作成可以批量读取的tensor数据。采用tourch.utils.data.Dataset构建。

Data思路：指定Mnist数据集的存储路径后，根据是否为训练集，找到对应的压缩包，解压文件并读取数据，利用Dataset构建迭代器，从而实现根据索引号返回一组图像和标签的数据。Dataset是一个抽象类，需要继承并重写。其中，根据Mnist数据集文件的命名和存储结构，构建了一个__read_data__私有函数，用来读取数据，返回图像和标签，在__init__中，初始化数据集，获取到原始的数据，在__getitem__中，根据index，返回一组图像和标签，这里可以对图像进行变换，在__len__中返回数据集的样本个数。
为了看懂最后输出的内容，生成了一个实列，取出一组数据，并展示，结果如下：

![1489774-20200612142405612-1101288477](https://user-images.githubusercontent.com/60682087/132391728-362de77a-80d4-48d7-885f-3b58814ade09.jpg)

图 1.1 从数据集中取出一张图展示

2. 模型构建

![1489774-20200612142354818-550303187](https://user-images.githubusercontent.com/60682087/132391873-cea98d34-1d90-445d-8dab-db8484bc47d6.jpg)

图 2.1 LeNet-5模型架构图

LeNet-5神经网络一共五层，其中卷积层和池化层可以考虑为一个整体，网络的结构为：
输入 -> 卷积 -> 池化 -> 卷积 -> 池化 -> 全连接 -> 全连接 -> 输出。
在pytorch中，图像数据集的存储顺序为：（batch, channels, height, width）依次为批大小，通道数，高度，宽度。所以，按照网络结构，各层的参数和输入输出关系，可以整理得到下表：

![1489774-20200612142436435-14573448082313](https://user-images.githubusercontent.com/60682087/132392271-3ba35e01-1b7f-4077-a043-433f10901f67.JPG)

表2.1 LeNet-5模型参数表

如上表所示，输入得Mnist数据集是灰度图，通道为1，长和宽都为28。经过pytorch处理后，可以生成批量数据，从而多出一个batch得维度数据。

这里需要特别注意的是，从第二此卷积池化后，与全连接层fc1进行数据传递时，是先把池化pool2的输出，除了batch之外的其他维度数据，展平到一个维度。然后送入全连接层。而这个数据的大小跟输入大小有关，因此在设计时，需要仔细推算每个层的输出。

由上面的分析，就可以搭建网络了。

Model思路：网络的构建需要继承torch.nn.Module，在 __init__ 中和forward中其实都是可以定义网络的，但是一般是在 __init__ 里定义一些主要的操作，然后在forward里输入数据，进行前向传播的表达。其中展平的操作利用viwe()实现，前面-1表示默认，即batch的大小，后面则是其余维度展平后的大小。
为了看清楚网络的各层参数，将其打印了：
<pre><code>
LeNet5(
  (conv1): Conv2d(1, 6, kernel_size=(5, 5), stride=(1, 1))
  (pool1): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
  (conv2): Conv2d(6, 16, kernel_size=(5, 5), stride=(1, 1))
  (pool2): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
  (fc1): Linear(in_features=256, out_features=120, bias=True)
  (fc2): Linear(in_features=120, out_features=84, bias=True)
  (fc3): Linear(in_features=84, out_features=10, bias=True)
)
</code></pre>

3.训练与测试

神经网络的训练主要包括了导入批数据，前向传播，反向传播，权重更新，如此循环迭代。遍历到一定的epoch数量后停止，得到训练好的模型。

随后，将图像送进网络进行测试即可。

Main思路: 利用torch.utils.data.DataLoader 从数据集中划分批次，然后打乱顺序，每次送入一个批次的数据到神经网络进行训练，每300个批次计算一次损失值。训练结束后，测试了在测试集上的准确率。最后又测试自己手动制作的单一的手写数字图像。

结果如下：

![1489774-2020061214240561212-110128847723](https://user-images.githubusercontent.com/60682087/132392925-437687c4-73c8-49e6-a7e0-2852a62e0875.JPG)

图3.1 loss迭代曲线
<pre><code>
Test set accuracy: 99%
tensor([8])
</code></pre>

![1489774-20200612142436435-1457344808](https://user-images.githubusercontent.com/60682087/132393146-d3b7a7e6-ce11-40ea-bda2-88abbb0de8fb.jpg)

图3.2 测试手写图

- 这个项目是我为了重新学习LeNet-5而做的项目（이 프로젝트는 내가 LeNet-5를 다시 공부하기위해서 만든 프로젝트입니다.）
